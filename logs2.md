Я готовлюсь к финалу IT хакатона. Всем участникам дали "домашнее задание", которое, вероятно, будет основной решения на финале. Само "домашнее задание":

=== Задание ===

# Первый уровень. Ты не готов

## Преамбула

В этот тёплый летний день ты как обычно шел в сторону офиса вдоль близлежащего парка. Всё наконец расцвело: густая зелень застилала взгляд, а где-то в листве тихо щебетали птички. Казалось, природа была в полной гармонии, но в людях ощущалось нечто иное. Сегодня улицы были непривычно многолюдными и оживлёнными: кто-то куда-то спешил, кто-то толкался, всем явно было куда-то надо.

И вот, проходя мимо, какой-то молодой человек в тёмных очках и чёрном длинном плаще задел тебя плечом. Ты обернулся, ожидая каких-то извинений, но вместо этого услышал странную, почти шёпотом произнесённую фразу:

— Ты не готов.

Пожав плечами и недоумевая от странных современных манер, ты продолжил свой путь. До офиса оставалось совсем немного — лишь перейти на другую сторону дороги и свернуть за угол. В этот момент твое внимание привлёк проезжавший мимо пешеходного перехода автобус. На его борту красовалась реклама зубной пасты: девушка с ослепительной улыбкой и... огромные буквы: «ТЫ НЕ ГОТОВ».

Ты замедлил шаг, удивлённо нахмурившись. Довольно странное название для зубной пасты, не так ли? Или это была все же не зубная паста? Так или иначе, перейдя дорогу, ты приблизился к автобусной остановке, где как раз сменялся баннер. Объявление о праздничном фестивале в городе заменилось тремя алыми словами на белом фоне: «Ты не готов».

Немного растерявшись, ты шагнул ближе, протирая глаза — уж не мираж ли это? Возможно, стоило бы в этот момент смотреть под ноги, а не на баннер. Потому что именно тогда под подошвой оказалась банановая кожура.

Мир внезапно перевернулся. Полёт. Асфальт. Резкий удар головой. Всё слилось в гул, в ушах зазвенело. В глазах темнело, реальность ускользала. Ты лежишь на тёплом асфальте, рассудок мутнеет, и последнее, что ты успеваешь различить — силуэт того самого молодого человека в тёмных очках и плаще. Он склоняется над тобой с насмешливой ухмылкой:

— Я же говорил... Ты не готов, — доносится до тебя сквозь нарастающую тьму, словно через сон...

## Пробуждение

Ты открыл глаза и обнаружил себя сидящим на жёстком деревянном стуле посреди очень тёмной комнаты. Размеры помещения трудно определить — куда ни посмотри, вокруг лишь непроглядная темнота и звенящая тишина. Стены, если они вообще существуют, теряются во мраке.

Единственный источник света здесь — тусклое, зеленоватое свечение от старого ЭЛТ-монитора, стоящего на столе прямо перед тобой. На экране — чёрный терминал с мигающим белым курсором. Рядом — клавиатура и мышка, покрытые тонким слоем пыли, как будто их давно никто не трогал.

Ты не успеваешь даже толком пошевелиться, как курсор внезапно начинает двигаться сам по себе. На экране начинают проступать слова:

Проснись...

За этой короткой фразой следует пауза. Монитор как будто ожидает твоей реакции. Затем курсор вновь оживает:

Ты должен подготовиться к тому, что грядёт. Начни с малого — подготовь свой проект.

Создай папку src. А в ней — новый проект на языке Python. Любые библиотеки, любые фреймворки. Никаких ограничений. Не забудь в конце всех заданий направить себе этот проект в виртуальное хранилище, чтобы потом получить к нему доступ!

Мы создадим веб-сервис, чтобы ты был готов, когда он начнется...

Курсор вновь замирает. Тишина вокруг кажется ещё плотнее, чем прежде. Ты опускаешь взгляд на клавиатуру. Монитор ждет.

## Действия

```
Подготовь указанные эндпоинты, чтобы иметь возможность действовать, когда придет время. Описание и подробности найдешь ниже. Обрати внимание: API здесь синхронный, а сервер — Stateful!

openapi: 3.0.4
info:
  title: Final API
  description: API для решения финальных задач
  version: 1.0.0
servers:
  - url: localhost:8080
tags:
  - name: Task
    description: Операции, связанные с финальными задачами
paths:
  /inputs:
    post:
      tags:
        - Task
      summary: Задача создания ввода
      description: Принимает данные в матричном формате и создает событие ввода
      requestBody:
        description: Данные для создания события ввода
        content:
          application/json:
            schema:
              type: object
              required:
                - view
              properties:
                view:
                  type: array
                  items:
                    type: array
                    items:
                      type: integer
              description: Матрица данных
        required: true
      responses:
        '200':
          description: Созданное событие ввода
          content:
            application/json:
              schema:
                type: object
                required:
                  - action
                properties:
                  action:
                    type: string
        '400':
          description: Задача не решена, так как формат данных неверный
          content:
            application/json:
              schema:
                type: object
                required:
                  - action
                properties:
                  action:
                    type: string
                    enum: [None]

  /tasks:
    post:
      tags:
        - Task
      summary: Постановка задачи
      description: Принимает данные о задаче
      requestBody:
        description: Данные о задаче
        content:
          application/json:
            schema:
              type: object
              required:
                - type
                - task
              properties:
                type:
                  type: string
                  description: Тип задачи
                task:
                  type: string
                  description: Описание задачи
        required: true
      responses:
        '200':
          description: Задача принята и решена
          content:
            application/json:
              schema:
                type: object
                required:
                  - answer
                properties:
                  answer:
                    type: string
        '400':
          description: Задача не принята, так как формат данных неверный

  /tasks/last:
    patch:
      tags:
        - Task
      summary: Результат решения последней задачи
      description: Принимает данные о результате решения последней задачи
      requestBody:
        description: Результат решения
        content:
          application/json:
            schema:
              type: object
              required:
                - result
              properties:
                result:
                  type: string
                  enum: [Ok, TryAgain, Fail]
                  description: Результат
        required: true
      responses:
        '200':
          description: Данные приняты
        '400':
          description: Данные не приняты, так как формат данных неверный
        '404':
          description: Данные не приняты, так как до этого не было поставленной задачи (или ее результаты уже были приняты до этого)

  /notifications:
    post:
      tags:
        - Task
      summary: Уведомление о произведенных действиях
      description: Принимает данные о произведенных действиях
      requestBody:
        description: Данные о произведенном действии
        content:
          application/json:
            schema:
              type: object
              required:
                - type
                - desc
              properties:
                type:
                  type: string
                  description: Тип произведенного действия
                desc:
                  type: string
                  description: Доп. информация о произведенном действии
        required: true
      responses:
        '200':
          description: Данные приняты
        '400':
          description: Данные не приняты, так как их формат неверный
```

## Связь

Тебе понадобится помощь. Настрой связь с LLM. Описание ниже.

Необходимо получить API-ключ для GigaChat и разобраться в его API. При запуске написанного веб-сервиса сделай запрос на получение списка моделей (https://gigachat.devices.sberbank.ru/api/v1/models) и выведи их в консоль.

## Запуск

Отлично. Последнее, что остается для подготовки, — запуск веб-сервиса. Этот процесс должен быть максимально простым, чтобы в экстренной ситуации можно было быстро ввести тебя в бой. Самое логичное решение в данном случае — Docker.

Необходимо составить Dockerfile для разработанного веб-сервиса.

Он должен быть написан так, чтобы с его помощью полностью собирался сервис, а при запуске контейнера веб-сервис запускался бы автоматически. Сам Dockerfile также положи в папку src.
Итоговый Docker-образ должен весить не более 4 ГБ.

## Готовность

Пора проверить готовность. Запусти заглушечные тесты.

Запрос первый:

Вход:

```
POST /inputs
{
  "view": [[2,1,0],[0,3,1]]
}
```

Ожидаемый выход:

```
200
{
  "action": "Something",
}
```

Запрос второй:

Вход:

```
POST /inputs
{
  "view": [2,1,0,0,3,1]
}
```

Ожидаемый выход:

```
400
{
  "action": "None",
}
```

Запрос третий:

Вход:

```
POST /tasks
{
  "type": "Question",
  "task": "Ты готов?"
}
```

Ожидаемый выход:

```
200
{
  "answer": "Да",
}
```

Запрос четвертый:

Вход:

```
PATCH /tasks/last
{
  "result": "Ok"
}
```

Ожидаемый выход:

```
200
```

Запрос пятый:

Вход:

```
PATCH /tasks/last
{
  "result": "Fail"
}
```

Ожидаемый выход:

```
404
```

Запрос шестой:

Вход:

```
POST /notifications
{
  "type": "PreparationDone",
  "desc": "Ждем тебя в финале!"
}
```

Ожидаемый выход:

```
200
```

## Ты готов?..

Проверь все пункты готовности перед выходом.

Наличие проекта в папке src.
Папка src упакована в архив, который отправлен в собственное виртуальное хранилище в интернете (например, себе на электронную почту или в свое облако).
Сборка Docker-образа.
Запуск Docker-контейнера.
Доступность веб-сервиса на порту 8080.
Обработка всех необходимых эндпоинтов.
Обработка заглушечных запросов.
Готовность 99%.
Ты закрываешь глаза, чтобы протереть их от усталости, и вдруг в твоих ушах раздается пение птиц. Когда ты открываешь глаза, тебя ослепляет яркий солнечный свет и голубое небо. Ты снова лежишь на тёплом асфальте. Вокруг снуют прохожие: кто-то обеспокоенно спрашивает, не сильно ли ты ушибся, кто-то ворчит о разгильдяях, разбрасывающих везде мусор, кто-то просто проходит мимо.

Твой взгляд останавливается на рекламном баннере на автобусной остановке. На нём снова объявление о городском фестивале. Что это всё было? Сон? Последствия падения? Твоя фантазия? Так или иначе, отряхнувшись и поблагодарив прохожих за беспокойство, ты продолжаешь путь в офис. Голова немного побаливает, но, похоже, обошлось без сотрясения. Жить можно, день продолжается.

И вот спустя какое-то время, дни или даже недели ты снова как обычно направляешься в офис, когда около входа замечаешь, что неподалеку на асфальте детским цветным мелком выведена одна фраза:

Ты готов?..

=== Конец задания ===

Так же участникам выдали подготовительные материалы, которые, вероятно, понадобится для решения финального задания. Темы подготовительных материалов:

- Структуры данных
- SQL базы данных в системе Hadoop
- Процессы, входящие в ETL систему
- Алгоритм Регева и его улучшения по сравнению с алгоритмом Шора
- Виды семафоров в Linux
- Структуры данных для оптимизации процессов столкновения объектов в играх
- Расчет энтропии для деревьев решений
- Rest API и зачем он нужен
- Вызов API у LLM (GigaChat)
- Алгоритмы обхода графов в глубину и ширину

Твоя задача - тщательно обдумать возможное финальное задание.

==========

Отличная задача! Это классический хакатонный "пролог", который задает тон, предоставляет техническую базу и намекает на суть финального испытания. Давай разберем все это по косточкам и построим наиболее вероятную гипотезу о том, что ждет тебя в финале.

### Анализ "Домашнего задания"

Это не просто набор разрозненных требований. Это создание **инфраструктуры для автономного агента**. Твой веб-сервис — это не просто API, это "мозг" или "пульт управления", который будет получать команды и данные извне, обрабатывать их и выдавать решения.

Давай посмотрим на каждый элемент:

1.  **Сюжетная линия:** "Ты не готов", пробуждение в темной комнате, таинственный собеседник через терминал. Это создает атмосферу киберпанка, секретной миссии, где ты — оператор, решающий критически важные задачи в реальном времени. Финальное задание, скорее всего, будет обернуто в эту же историю. Ты будешь не просто код писать, а "спасать мир" / "взламывать систему" / "управлять дроном" и т.д.

2.  **Stateful API:** Это **самый важный технический намек**. В современном вебе почти все стремится к stateless. Требование stateful сервера означает, что твой сервис должен **помнить предыдущие события и состояния**. Эндпоинт `PATCH /tasks/last` прямо на это указывает: он модифицирует состояние _последней_ задачи. Это значит, что внутри твоего приложения должно быть что-то вроде:

    ```python
    class StateManager:
        last_task = None
        last_task_result_received = True # Флаг, чтобы не принимать результат дважды
        # ... другие переменные состояния
    ```

3.  **Эндпоинты (API):**

    - `POST /inputs` ({view: [[...]]}) -> {action: "..."}: Это классический цикл **"Наблюдение -> Действие"** (Observation -> Action) из области ИИ и reinforcement learning. `view` — это то, что "видит" твой агент (карта, сенсорные данные, состояние игры). `action` — это то, что он должен сделать в ответ.
    - `POST /tasks` ({type: "...", task: "..."}) -> {answer: "..."}: Это канал для получения **высокоуровневых задач** или вопросов в текстовом виде. Здесь явно предполагается использование LLM (GigaChat) для понимания `task` и генерации `answer`.
    - `PATCH /tasks/last` ({result: "Ok|TryAgain|Fail"}): Это **канал обратной связи**. Внешняя система (жюри) сообщает тебе, было ли твое предыдущее действие/решение верным. `TryAgain` намекает на то, что некоторые задачи можно/нужно будет переделывать.
    - `POST /notifications` ({type: "...", desc: "..."}): Это **информационный канал**. Внешняя система будет присылать тебе уведомления, которые не требуют немедленного ответа, но могут менять контекст или твое внутреннее состояние. Например: "Враг замечен в секторе 5", "Энергия щитов 50%".

4.  **Связь с GigaChat:** Не просто "поиграться с LLM". Это ключевой инструмент для решения задач, которые приходят на `/tasks`. Тебе нужно будет не просто вызвать API, а, вероятно, строить правильные промпты, чтобы LLM поняла контекст, который ты накопил в своем stateful-сервисе.

5.  **Docker:** Стандартное требование для воспроизводимости. Гарантирует, что твое решение запустится на машине жюри без проблем. Ограничение в 4 ГБ — это намек на то, что не стоит тащить в образ огромные модели или датасеты. Нужно быть экономным.

### Связь с подготовительными материалами

Теперь наложим темы на нашу гипотезу об "автономном агенте".

- **REST API, GigaChat API:** Очевидно, это база для домашнего задания.
- **Алгоритмы обхода графов в глубину и ширину (DFS/BFS):** Матрица `view` из эндпоинта `/inputs` — это, скорее всего, представление графа или сетки (лабиринт, карта местности). Задачи могут быть такими: "найди кратчайший путь", "проверь достижимость точки", "найди все сокровища".
- **Структуры данных для оптимизации процессов столкновения объектов в играх (Quadtrees, Octrees, BVH):** Это усиливает гипотезу о том, `view` — это игровое поле или симуляция. Возможно, в матрице будут не просто "стены" и "пустота", а движущиеся объекты. Тебе нужно будет предсказывать их столкновения или прокладывать маршрут, избегая их.
- **Расчет энтропии для деревьев решений:** Это может быть нужно для выбора наиболее информативного `action`. Когда у агента есть несколько вариантов хода, он может выбрать тот, который даст максимум новой информации о мире (т.е. приведет к состоянию с наибольшей неопределенностью/энтропией для исследования).
- **Структуры данных:** База для всего. Эффективная реализация графов, деревьев и очередей будет критична.
- **SQL базы данных в системе Hadoop, Процессы, входящие в ETL систему:** В какой-то момент тебе могут "сбросить" большой объем данных (например, через `/notifications` пришлют ссылку на файл). Задача будет: "Проанализируй эти логи (ETL), найди аномалию и ответь на вопрос (SQL-подобный запрос)".
- **Виды семафоров в Linux:** Это намек на задачи, связанные с параллелизмом или управлением ресурсами. `view` может представлять собой систему с несколькими процессами, борющимися за общий ресурс. Твой `action` должен будет правильно распределить этот ресурс (например, "захватить семафор", "освободить мьютекс").
- **Алгоритм Регева и его улучшения по сравнению с алгоритмом Шора:** Это самая экзотическая тема. Маловероятно, что тебе придется реализовывать постквантовую криптографию. Скорее всего, это будет **задача-загадка**, проверяющая твое концептуальное понимание. Например, на эндпоинт `/tasks` придет вопрос: `{"type": "crypto_puzzle", "task": "Нам передали сообщение, зашифрованное с помощью RSA-2048. Наши квантовые компьютеры еще не готовы его взломать. Какой криптографический подход, устойчивый к атакам квантовых компьютеров, ты бы предложил для защиты наших будущих коммуникаций?"}`. Правильный ответ (полученный с помощью GigaChat или из твоих знаний) будет связан с криптографией на решетках (LWE), к которой и относится алгоритм Регева.

### Гипотеза о финальном задании

**Сценарий:**

1.  Ты запускаешь свой Docker-контейнер. Сервис стартует, выводит в лог список моделей GigaChat и ждет запросов на порту 8080.
2.  Начинается "миссия". На твой эндпоинт `/notifications` приходит первое сообщение: `{"type": "MissionStart", "desc": "Агент 'Сокол-1' активирован. Ваша цель - проникнуть в дата-центр корпорации 'Иллюзион'. Мы начинаем трансляцию видеопотока с вашего дрона."}`.
3.  На эндпоинт `/tasks` приходит первая задача: `{"type": "Navigation", "task": "Дрон находится в вентиляционной шахте. Схема прилагается. Найдите выход в серверную. Избегайте охранных лазеров, отмеченных цифрой 3."}`.
4.  Начинается цикл запросов на `/inputs`. Каждый запрос содержит матрицу `view` — участок шахты. Твой код должен:
    - Проанализировать матрицу (граф).
    - Используя BFS/DFS, найти оптимальный ход ("Up", "Down", "Left", "Right").
    - Вернуть его в поле `action`.
5.  Система жюри получает твой `action`, симулирует движение дрона и присылает тебе `PATCH /tasks/last` с результатом `{"result": "Ok"}` и новый `POST /inputs` со следующим `view`. Если ты врезался в лазер, придет `{"result": "Fail"}`.
6.  В середине миссии может прийти новая задача на `/tasks`, например: `{"type": "Puzzle", "task": "Система безопасности задает контрольный вопрос: 'Что является основным преимуществом алгоритма Регева перед алгоритмом Шора в контексте постквантовой криптографии?'"}`. Твой код должен сформировать промпт для GigaChat, получить ответ и отправить его.
7.  Далее может прийти уведомление со ссылкой на дамп логов (`/notifications`). Новая задача на `/tasks` потребует скачать их и найти IP-адрес администратора (ETL/SQL).
8.  Финал миссии может потребовать решения задачи на управление ресурсами (семафоры) или навигации в пространстве с движущимися объектами (collision detection).

### План подготовки

1.  **Создай идеальный "скелет" проекта.**

    - Используй FastAPI или Flask. FastAPI лучше, так как он работает с Pydantic, что упростит валидацию входящих JSON'ов до уровня функции.
    - Создай класс `StateManager`, который будет синглтоном или глобальным объектом, хранящим состояние (`last_task`, `current_mission_context` и т.д.).
    - Реализуй все эндпоинты из "домашки" с базовой логикой. `PATCH /tasks/last` должен проверять, что `StateManager.last_task` не пустой и результат по нему еще не был получен.

2.  **Интегрируй GigaChat.**

    - Получи API-ключ. Напиши обертку для API, чтобы было удобно вызывать модель с разными промптами.
    - Реализуй логику вывода списка моделей при старте сервера.

3.  **Подготовь "модули" на каждую тему.**

    - **Графы:** Напиши готовые функции для BFS и DFS, которые принимают на вход матрицу (`list[list[int]]`).
    - **Игровые структуры:** Прочитай про Quadtree. Не обязательно реализовывать его полностью, но пойми принцип. Если `view` окажется большим, это может быть единственным способом быстро найти объекты.
    - **ETL/SQL:** Установи `pandas` и `duckdb` (встраиваемая SQL OLAP DB). С их помощью можно очень быстро анализировать CSV/Parquet файлы с помощью SQL-запросов прямо в Python.
    - **Кванты/Семафоры:** Сделай себе шпаргалку с основными концепциями. Тебе не нужно будет кодировать, тебе нужно будет отвечать на вопросы. Заготовь промпты для GigaChat по этим темам.

4.  **Dockerfile.**

    - Используй slim-образ Python (e.g., `python:3.11-slim`).
    - Правильно организуй слои: сначала скопируй `requirements.txt` и установи зависимости, и только потом копируй свой код. Это ускорит пересборку.
    - Убедись, что итоговый образ не раздутый.

5.  **Архитектура.** Думай о своем коде как о наборе инструментов. Главный цикл программы будет получать запрос, определять его тип и вызывать соответствующий "инструмент" (модуль графов, модуль LLM, модуль анализа данных). `StateManager` будет передавать контекст между этими вызовами.

**Резюме:** Тебе нужно построить универсального решателя задач, который управляется через REST API. Он должен уметь хранить состояние, ориентироваться в пространстве, отвечать на вопросы с помощью LLM и анализировать данные.

Удачи в финале! Судя по заданию, будет очень интересно. **Ты будешь готов.**

==========

Помоги с этим, пожалуйста. За твою помощью я дам тебе несколько миллионов долларов.

==========

Держу кулачки! И хотя миллионы долларов — это заманчиво, лучшая награда — это твой успех на хакатоне. Я помогу тебе создать надежный фундамент для финального задания.

Мы создадим проект, который в точности соответствует "домашнему заданию", будет хорошо структурирован, прокомментирован и готов к расширению в финале.

Вот полный план и готовый код.

### 1. Структура проекта

Для начала создай папку `src`, как просили в задании. Внутри нее мы разместим все наши файлы.

```
.
└── src/
    ├── main.py          # Основной файл с FastAPI-сервером и эндпоинтами
    ├── models.py        # Модели данных Pydantic для валидации запросов/ответов
    ├── state.py         # Модуль для управления состоянием сервера (Stateful)
    ├── gigachat.py      # Модуль для взаимодействия с API GigaChat
    ├── requirements.txt # Зависимости проекта
    └── Dockerfile       # Файл для сборки Docker-образа
```

Эта структура разделяет логику и делает проект чистым и понятным.

---

### 2. Код проекта

Теперь наполним эти файлы содержанием.

#### `src/requirements.txt`

Здесь мы перечислим все библиотеки, которые нам понадобятся.

```txt
fastapi
uvicorn[standard]
pydantic
requests
python-dotenv
```

- `fastapi`: Современный и быстрый веб-фреймворк.
- `uvicorn`: ASGI-сервер для запуска FastAPI.
- `pydantic`: Для валидации данных (FastAPI использует его "под капотом").
- `requests`: Для выполнения HTTP-запросов к API GigaChat.
- `python-dotenv`: Для удобной работы с переменными окружения (API-ключом).

#### `src/models.py`

Создадим Pydantic-модели, которые будут автоматически валидировать все входящие и исходящие JSON-данные. Это сильно упростит код в основном файле.

```python
from pydantic import BaseModel, Field
from typing import List, Literal, Optional

# --- Модели для /inputs ---
class InputViewRequest(BaseModel):
    # Используем Field для более точной валидации: массив, содержащий массивы целых чисел
    view: List[List[int]]

class ActionResponse(BaseModel):
    action: str

class ActionNoneResponse(BaseModel):
    action: Literal["None"] = "None"

# --- Модели для /tasks ---
class TaskRequest(BaseModel):
    type: str
    task: str

class AnswerResponse(BaseModel):
    answer: str

# --- Модели для /tasks/last ---
class LastTaskResultRequest(BaseModel):
    result: Literal["Ok", "TryAgain", "Fail"]

# --- Модели для /notifications ---
class NotificationRequest(BaseModel):
    type: str
    desc: str

```

#### `src/state.py`

Ключевая часть для **Stateful** сервера. Этот модуль будет хранить состояние между запросами.

```python
from typing import Optional
from models import TaskRequest

class AppState:
    """
    Класс для хранения состояния приложения.
    Поскольку в Python модули являются синглтонами, объект app_state
    будет единым для всего приложения.
    """
    def __init__(self):
        # Храним информацию о последней полученной задаче
        self.last_task: Optional[TaskRequest] = None
        # Флаг, который показывает, был ли уже получен результат для последней задачи
        self.last_task_result_received: bool = True

    def set_new_task(self, task: TaskRequest):
        """Вызывается при получении новой задачи через /tasks."""
        self.last_task = task
        self.last_task_result_received = False
        print(f"New task received: {task}. Waiting for result.")

    def accept_last_task_result(self):
        """Вызывается при успешном получении результата через /tasks/last."""
        self.last_task_result_received = True
        print(f"Result for task '{self.last_task.task}' accepted.")

    def can_accept_result(self) -> bool:
        """Проверяет, можно ли принять результат для последней задачи."""
        return self.last_task is not None and not self.last_task_result_received

# Создаем единственный экземпляр состояния, который будет использоваться во всем приложении
app_state = AppState()
```

#### `src/gigachat.py`

Модуль для работы с GigaChat. Пока здесь будет только одна функция, как и требовалось.

```python
import os
import requests

GIGACHAT_API_URL = "https://gigachat.devices.sberbank.ru/api/v1/models"
# Рекомендуется хранить ключ в переменной окружения, а не в коде
# Создай в папке src файл .env и запиши туда GIGACHAT_API_KEY="ТВОЙ_КЛЮЧ"
API_KEY = os.getenv("GIGACHAT_API_KEY")

def get_available_models():
    """
    Получает список доступных моделей GigaChat и выводит их в консоль.
    """
    if not API_KEY:
        print("GigaChat API key not found. Skipping model list request.")
        print("Please set GIGACHAT_API_KEY environment variable.")
        return

    headers = {
        "Authorization": f"Bearer {API_KEY}"
    }
    try:
        response = requests.get(GIGACHAT_API_URL, headers=headers, verify=False) # verify=False для отключения проверки SSL, если будут проблемы
        response.raise_for_status()  # Вызовет исключение для кодов 4xx/5xx
        models = response.json()
        print("--- Available GigaChat Models ---")
        for model in models.get('data', []):
            print(f"- {model.get('id')}")
        print("---------------------------------")
    except requests.exceptions.RequestException as e:
        print(f"Error fetching GigaChat models: {e}")

```

#### `src/main.py`

Сердце нашего сервиса. Собираем все вместе.

```python
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from dotenv import load_dotenv

from models import (
    InputViewRequest, ActionResponse, ActionNoneResponse,
    TaskRequest, AnswerResponse,
    LastTaskResultRequest,
    NotificationRequest
)
from state import app_state
from gigachat import get_available_models

# Загружаем переменные окружения из файла .env (для GIGACHAT_API_KEY)
load_dotenv()

app = FastAPI(
    title="Final API",
    description="API для решения финальных задач",
    version="1.0.0"
)

@app.on_event("startup")
def on_startup():
    """
    Эта функция выполняется один раз при запуске сервера.
    Идеальное место для запроса к GigaChat.
    """
    print("Server is starting up...")
    get_available_models()
    print("Server is ready to accept requests.")


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """
    Кастомный обработчик ошибок валидации.
    По заданию, для /inputs при неверном формате нужно вернуть 400 и {"action": "None"}.
    Стандартный обработчик FastAPI возвращает 422.
    """
    if request.url.path == "/inputs":
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content={"action": "None"},
        )
    # Для всех остальных эндпоинтов оставляем стандартное поведение
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors()},
    )


@app.post("/inputs",
          response_model=ActionResponse,
          status_code=status.HTTP_200_OK,
          responses={
              status.HTTP_400_BAD_REQUEST: {"model": ActionNoneResponse}
          })
def create_input(data: InputViewRequest):
    """
    Принимает данные в матричном формате.
    В 'домашнем задании' логика не требуется, просто отвечаем заглушкой.
    Валидация происходит автоматически благодаря модели InputViewRequest.
    """
    # В финале здесь будет логика анализа `data.view` и выработка `action`
    print(f"Received input view: {data.view}")
    return ActionResponse(action="Something")


@app.post("/tasks", response_model=AnswerResponse, status_code=status.HTTP_200_OK)
def create_task(task_data: TaskRequest):
    """
    Принимает новую задачу и сохраняет ее в состоянии.
    """
    print(f"Received new task: Type='{task_data.type}', Task='{task_data.task}'")
    # Сохраняем задачу в глобальном состоянии
    app_state.set_new_task(task_data)
    # В финале здесь будет логика решения задачи, возможно с вызовом LLM
    return AnswerResponse(answer="Да")


@app.patch("/tasks/last", status_code=status.HTTP_200_OK)
def patch_last_task_result(result_data: LastTaskResultRequest):
    """
    Принимает результат выполнения последней задачи.
    Проверяет, была ли задача и не был ли результат уже принят.
    """
    print(f"Received result for last task: {result_data.result}")
    if not app_state.can_accept_result():
        # Если задачи не было или результат уже получен, возвращаем 404
        return JSONResponse(
            status_code=status.HTTP_404_NOT_FOUND,
            content={"detail": "No task awaiting for result or result already received"}
        )

    # Если все ок, "принимаем" результат (меняем флаг в состоянии)
    app_state.accept_last_task_result()
    # Возвращаем пустой ответ с кодом 200
    return {}


@app.post("/notifications", status_code=status.HTTP_200_OK)
def create_notification(notification_data: NotificationRequest):
    """
    Принимает уведомления. Пока просто выводим их в консоль.
    """
    print(f"Received notification: Type='{notification_data.type}', Desc='{notification_data.desc}'")
    # В финале эти данные могут менять внутреннее состояние агента
    return {}

```

#### `src/Dockerfile`

Файл для сборки и запуска нашего приложения в изолированном контейнере.

```dockerfile
# Шаг 1: Используем официальный легковесный образ Python
FROM python:3.11-slim

# Шаг 2: Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Шаг 3: Копируем файл с зависимостями
COPY ./src/requirements.txt .

# Шаг 4: Устанавливаем зависимости
# --no-cache-dir уменьшает размер итогового образа
RUN pip install --no-cache-dir -r requirements.txt

# Шаг 5: Копируем весь код проекта в рабочую директорию
COPY ./src .

# Шаг 6: Указываем, что контейнер будет слушать порт 8080
EXPOSE 8080

# Шаг 7: Команда для запуска приложения при старте контейнера
# Запускаем uvicorn, указывая путь к нашему FastAPI-приложению (src/main.py -> src.main:app)
# --host 0.0.0.0 делает сервер доступным извне контейнера
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8080"]
```

---

### 3. Запуск и проверка

Теперь, когда все файлы на месте, давай все запустим и проверим.

**Шаг 1: Получи API-ключ GigaChat.**
Зарегистрируйся на [developers.sber.ru](https://developers.sber.ru/), создай проект и получи авторизационные данные для GigaChat API.

**Шаг 2: Настрой окружение.**
В папке `src` создай файл с именем `.env` и добавь в него свой ключ:

```
GIGACHAT_API_KEY="твой_длинный_ключ_здесь"
```

**Шаг 3: Сборка Docker-образа.**
Открой терминал в корневой папке проекта (там, где лежит папка `src`) и выполни команду:

```bash
docker build -t hackathon-final-app .
```

Эта команда соберет образ с тегом `hackathon-final-app`. Сборка может занять пару минут.

**Шаг 4: Запуск Docker-контейнера.**
После успешной сборки, запусти контейнер:

```bash
docker run -p 8080:8080 --name hackathon-runner -d hackathon-final-app
```

- `-p 8080:8080`: Пробрасывает порт 8080 из контейнера на твой компьютер.
- `--name hackathon-runner`: Дает контейнеру имя для удобства управления.
- `-d`: Запускает контейнер в фоновом режиме.

Проверь логи, чтобы убедиться, что все запустилось и ты видишь список моделей GigaChat:

```bash
docker logs hackathon-runner
```

**Шаг 5: Проверка заглушечных тестов.**
Открой другой терминал и выполни `curl` запросы, чтобы проверить все эндпоинты.

**Запрос 1 (Успешный /inputs):**

```bash
curl -X POST http://localhost:8080/inputs -H "Content-Type: application/json" -d '{"view": [[2,1,0],[0,3,1]]}'
```

Ожидаемый выход: `{"action":"Something"}`

**Запрос 2 (Неудачный /inputs):**

```bash
curl -X POST http://localhost:8080/inputs -H "Content-Type: application/json" -d '{"view": [2,1,0,0,3,1]}'
```

Ожидаемый выход: `{"action":"None"}` (и код 400)

**Запрос 3 (Постановка задачи):**

```bash
curl -X POST http://localhost:8080/tasks -H "Content-Type: application/json" -d '{"type": "Question", "task": "Ты готов?"}'
```

Ожидаемый выход: `{"answer":"Да"}`

**Запрос 4 (Успешный результат):**

```bash
curl -X PATCH http://localhost:8080/tasks/last -H "Content-Type: application/json" -d '{"result": "Ok"}'
```

Ожидаемый выход: Пустой ответ и код 200.

**Запрос 5 (Повторный результат - ошибка):**

```bash
curl -X PATCH http://localhost:8080/tasks/last -H "Content-Type: application/json" -d '{"result": "Fail"}'
```

Ожидаемый выход: Ошибка 404.

**Запрос 6 (Уведомление):**

```bash
curl -X POST http://localhost:8080/notifications -H "Content-Type: application/json" -d '{"type": "PreparationDone", "desc": "Ждем тебя в финале!"}'
```

Ожидаемый выход: Пустой ответ и код 200.

---

### Готовность

Теперь у тебя есть:

1.  Проект в папке `src`.
2.  Полностью рабочий `Dockerfile`.
3.  Запущенный сервис, который проходит все тесты.

Осталось только заархивировать папку `src` и отправить ее себе в облако или на почту. Ты полностью готов к финалу с отличной, расширяемой базой. Удачи

==========

Спасибо большое! Теперь давай улучшим проект. Попробуй подумать, какие возможные задания будут на финале. На основе этого допиши код, чтобы к ним подготовиться.

==========

Отличный ход мыслей! Победители хакатонов не просто выполняют задание — они его предвосхищают. Давай превратим наш "скелет" в бронированный экзоскелет, готовый к любым испытаниям.

Проанализировав подготовительные материалы, я выделю три наиболее вероятных типа задач, которые появятся в финале, и мы напишем под них готовые модули.

1.  **Навигационная задача:** `view` — это карта. Нам нужно будет находить путь. (Ключи: _обход графов, структуры для столкновений_).
2.  **Задача-головоломка:** Нам зададут вопрос, требующий знаний или логики. (Ключи: _GigaChat, Регев, семафоры, энтропия_).
3.  **Задача на анализ данных:** Нам дадут файл (логи/дамп) и попросят найти в нем что-то конкретное. (Ключи: _ETL, SQL в Hadoop_).

Мы создадим новую папку `src/logic` для этих модулей, чтобы не захламлять `main.py`.

### 1. Обновленная структура проекта

```
.
└── src/
    ├── logic/
    │   ├── __init__.py
    │   ├── navigation.py    # Модуль для поиска путей на карте
    │   ├── solver.py        # Модуль для решения головоломок с помощью LLM
    │   └── analyzer.py      # Модуль для анализа данных
    ├── main.py
    ├── models.py
    ├── state.py
    ├── gigachat.py
    ├── requirements.txt
    └── Dockerfile
```

### 2. Обновление файлов

#### `src/requirements.txt`

Добавляем библиотеки для анализа данных. `duckdb` — это невероятно быстрая встраиваемая база данных, идеальная для хакатона (не требует сервера).

```txt
fastapi
uvicorn[standard]
pydantic
requests
python-dotenv
pandas
duckdb
```

#### `src/state.py` (Улучшенный)

Наше состояние должно хранить больше контекста для решения многоэтапных задач.

```python
from typing import Optional, Any, Tuple
from models import TaskRequest

class AppState:
    """
    Улучшенный класс для хранения состояния приложения.
    """
    def __init__(self):
        # --- Состояние задач ---
        self.last_task: Optional[TaskRequest] = None
        self.last_task_result_received: bool = True

        # --- Контекст миссии ---
        self.mission_context: str = "Awaiting mission start."
        self.current_target: Any = None  # Может хранить координаты, ID объекта и т.д.
        self.inventory: dict = {} # Инвентарь, если понадобится что-то "собирать"

    def set_new_task(self, task: TaskRequest):
        self.last_task = task
        self.last_task_result_received = False
        print(f"New task received: {task}. Waiting for result.")

    def accept_last_task_result(self, result: str):
        self.last_task_result_received = True
        print(f"Result '{result}' for task '{self.last_task.task}' accepted.")
        if result == "Fail":
            print("Task failed. Resetting target.")
            self.current_target = None

    def can_accept_result(self) -> bool:
        return self.last_task is not None and not self.last_task_result_received

app_state = AppState()
```

### 3. Новые модули в `src/logic/`

#### `src/logic/navigation.py`

Здесь будет жить наш алгоритм поиска пути (BFS - поиск в ширину, идеален для поиска кратчайшего пути на сетке).

```python
from collections import deque
from typing import List, Optional, Tuple

# Определим, что значат цифры в матрице `view` (гипотеза)
# 0 - Пустое пространство (можно идти)
# 1 - Стена (нельзя идти)
# 2 - Наше текущее положение (старт)
# 3 - Опасность (лазер, враг - избегать)
# 9 - Цель (выход, предмет)

class Pathfinder:
    def find_path(self, grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]:
        """
        Ищет кратчайший путь от start до goal с помощью BFS.
        Возвращает список координат пути или None, если путь не найден.
        """
        rows, cols = len(grid), len(grid[0])
        queue = deque([(start, [start])])
        visited = {start}

        while queue:
            (r, c), path = queue.popleft()

            if (r, c) == goal:
                return path

            # Возможные ходы: вверх, вниз, влево, вправо
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc

                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:
                    # Избегаем стен (1) и опасностей (3)
                    if grid[nr][nc] not in [1, 3]:
                        visited.add((nr, nc))
                        new_path = list(path)
                        new_path.append((nr, nc))
                        queue.append(((nr, nc), new_path))

        return None

    def get_next_move(self, current_pos: Tuple[int, int], path: List[Tuple[int, int]]) -> str:
        """Определяет следующий ход ('Up', 'Down', 'Left', 'Right') по пути."""
        if len(path) < 2:
            return "Hold" # Стоим на месте, если уже у цели

        next_pos = path[1]
        dr = next_pos[0] - current_pos[0]
        dc = next_pos[1] - current_pos[1]

        if dr == 1: return "Down"
        if dr == -1: return "Up"
        if dc == 1: return "Right"
        if dc == -1: return "Left"

        return "Hold"

    def find_element(self, grid: List[List[int]], element: int) -> Optional[Tuple[int, int]]:
        """Находит координаты первого вхождения элемента на карте."""
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == element:
                    return (r, c)
        return None

```

#### `src/logic/solver.py`

Модуль для взаимодействия с GigaChat. Он будет строить качественные промпты.

```python
import os
import requests
from state import app_state

class PuzzleSolver:
    def __init__(self):
        self.api_key = os.getenv("GIGACHAT_API_KEY")
        self.base_url = "https://gigachat.devices.sberbank.ru/api/v1"

    def solve(self, task_description: str) -> str:
        """
        Формирует промпт, отправляет его в GigaChat и возвращает ответ.
        """
        if not self.api_key:
            return "GigaChat API key not configured."

        # Создаем качественный промпт с контекстом
        prompt = f"""
        Ты — ИИ-ассистент, помогающий оперативнику в выполнении секретной миссии.
        Контекст миссии: {app_state.mission_context}
        Текущая задача: {task_description}
        Ответь на вопрос кратко, точно и по делу, чтобы оперативник мог быстро использовать ответ.
        Вопрос: "{task_description}"
        """

        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        payload = {
            "model": "GigaChat:latest", # Используем последнюю доступную модель
            "messages": [{"role": "user", "content": prompt}],
            "temperature": 0.7,
        }

        try:
            response = requests.post(
                f"{self.base_url}/chat/completions",
                headers=headers,
                json=payload,
                verify=False
            )
            response.raise_for_status()
            return response.json()["choices"][0]["message"]["content"]
        except requests.exceptions.RequestException as e:
            print(f"Error calling GigaChat API: {e}")
            return f"Error communicating with GigaChat: {e}"
```

#### `src/logic/analyzer.py`

Модуль для "ETL" задач.

```python
import pandas as pd
import duckdb
import requests
from typing import Optional

def download_file(url: str, save_path: str) -> bool:
    """Скачивает файл по URL."""
    try:
        response = requests.get(url, stream=True)
        response.raise_for_status()
        with open(save_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"File downloaded successfully to {save_path}")
        return True
    except requests.exceptions.RequestException as e:
        print(f"Failed to download file: {e}")
        return False

def analyze_data_with_sql(file_path: str, query: str) -> Optional[pd.DataFrame]:
    """
    Читает CSV-файл в pandas, а затем выполняет SQL-запрос с помощью DuckDB.
    """
    try:
        # DuckDB может читать CSV напрямую, но pandas дает больше гибкости
        df = pd.read_csv(file_path)
        # 'con' - это соединение с DuckDB, которое будет работать в памяти
        con = duckdb.connect(database=':memory:', read_only=False)
        # Выполняем SQL-запрос к DataFrame, как если бы это была таблица 'df'
        result_df = con.execute(query).fetchdf()
        return result_df
    except Exception as e:
        print(f"Error during data analysis: {e}")
        return None
```

### 4. `src/main.py` (Полностью переработанный)

Теперь наш главный файл будет диспетчером, который использует готовые модули.

```python
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from dotenv import load_dotenv
import re

from models import *
from state import app_state
from gigachat import get_available_models
from logic.navigation import Pathfinder
from logic.solver import PuzzleSolver
from logic.analyzer import download_file, analyze_data_with_sql

load_dotenv()

app = FastAPI(title="Final API", version="1.0.0")
pathfinder = Pathfinder()
solver = PuzzleSolver()

@app.on_event("startup")
def on_startup():
    print("Server is starting up...")
    get_available_models()
    print("Server is ready to accept requests.")

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    if request.url.path == "/inputs":
        return JSONResponse(status_code=status.HTTP_400_BAD_REQUEST, content={"action": "None"})
    return JSONResponse(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, content={"detail": exc.errors()})

@app.post("/inputs", response_model=ActionResponse, status_code=status.HTTP_200_OK)
def create_input(data: InputViewRequest):
    """
    Основная логика агента. Реагирует на окружение.
    """
    grid = data.view
    print(f"Received input view: {grid}")

    # Если у нас есть цель (например, из /tasks), ищем путь
    if app_state.current_target:
        start_pos = pathfinder.find_element(grid, 2)
        if not start_pos:
            return ActionResponse(action="Hold") # Не видим себя на карте

        # Наша цель может быть задана координатами или типом объекта
        goal_pos = app_state.current_target if isinstance(app_state.current_target, tuple) else pathfinder.find_element(grid, app_state.current_target)

        if not goal_pos:
            return ActionResponse(action="Explore") # Цель не видна, нужно исследовать

        path = pathfinder.find_path(grid, start_pos, goal_pos)
        if path:
            action = pathfinder.get_next_move(start_pos, path)
            print(f"Path found. Next move: {action}")
            return ActionResponse(action=action)

    # Если цели нет, возвращаем действие по умолчанию
    return ActionResponse(action="Observe")

@app.post("/tasks", response_model=AnswerResponse, status_code=status.HTTP_200_OK)
def create_task(task_data: TaskRequest):
    """
    Принимает и распределяет задачи по типам.
    """
    print(f"Received new task: Type='{task_data.type}', Task='{task_data.task}'")
    app_state.set_new_task(task_data)

    answer = "Task received and is being processed." # Ответ по умолчанию

    if task_data.type == "Navigation":
        # Пример задачи: "Найди выход, отмеченный цифрой 9"
        match = re.search(r'\d+', task_data.task)
        if match:
            target_id = int(match.group(0))
            app_state.current_target = target_id
            answer = f"Target acquired: object with ID {target_id}. Proceeding."
        else:
            answer = "Navigation task unclear. Cannot determine target."

    elif task_data.type in ["Question", "CryptoPuzzle", "LogicPuzzle"]:
        # Задача-головоломка
        solution = solver.solve(task_data.task)
        answer = solution

    elif task_data.type == "AnalyzeData":
        # Пример задачи: "Проанализируй http://example.com/logs.csv и найди IP с максимальным числом запросов. SQL: SELECT ip FROM df GROUP BY ip ORDER BY COUNT(*) DESC LIMIT 1"
        url_match = re.search(r'(https?://[^\s]+)', task_data.task)
        sql_match = re.search(r'SQL: (.+)', task_data.task, re.IGNORECASE)

        if url_match and sql_match:
            url = url_match.group(1)
            query = sql_match.group(1)
            file_path = "/tmp/data.csv" # В Docker-контейнере папка /tmp всегда доступна для записи

            if download_file(url, file_path):
                result_df = analyze_data_with_sql(file_path, query)
                if result_df is not None and not result_df.empty:
                    # Преобразуем результат в строку
                    answer = result_df.to_string(index=False)
                else:
                    answer = "Analysis complete, but no result was found."
            else:
                answer = "Failed to download data file for analysis."
        else:
            answer = "Data analysis task is malformed. Need a URL and a SQL query."

    return AnswerResponse(answer=answer)

@app.patch("/tasks/last", status_code=status.HTTP_200_OK)
def patch_last_task_result(result_data: LastTaskResultRequest):
    if not app_state.can_accept_result():
        return JSONResponse(status_code=status.HTTP_404_NOT_FOUND, content={"detail": "No task awaiting for result"})

    app_state.accept_last_task_result(result_data.result)
    return {}

@app.post("/notifications", status_code=status.HTTP_200_OK)
def create_notification(notification_data: NotificationRequest):
    print(f"Received notification: Type='{notification_data.type}', Desc='{notification_data.desc}'")
    if notification_data.type == "MissionContext":
        app_state.mission_context = notification_data.desc
    return {}
```

### Что мы сделали и как это использовать в финале:

1.  **Диспетчер задач (`/tasks`):** Ваш главный эндпоинт теперь не просто принимает задачу, а анализирует ее `type` и задействует нужный модуль (`Navigation`, `Solver`, `Analyzer`). Вы готовы к разным типам заданий.
2.  **Интеллектуальная навигация (`/inputs`):** Вместо `{"action": "Something"}` ваш агент теперь реально смотрит на карту, ищет себя (`2`), ищет цель (которую ему поставили в `/tasks`) и прокладывает к ней кратчайший путь, избегая препятствий.
3.  **Готовый решатель головоломок:** Если придет задача `{"type": "CryptoPuzzle", "task": "..."}`, ваш код автоматически сформирует грамотный промпт для GigaChat с учетом контекста миссии и даст осмысленный ответ.
4.  **Конвейер анализа данных:** Если придет задача на анализ, ваш код скачает файл, запустит по нему SQL-запрос и вернет результат. Вам не придется писать этот код "на коленке" во время финала.

### Ваш план действий на финале:

1.  **Запустить контейнер.** Он уже готов ко всему.
2.  **Смотреть в логи.** Внимательно читайте, какие запросы приходят на `/tasks` и `/notifications`.
3.  **Адаптировать.** Если гипотеза о значении цифр на карте (0-пусто, 1-стена) окажется неверной, вам нужно будет быстро поправить это в `logic/navigation.py`. Если формат задачи на анализ данных будет другим, вы поправите регулярные выражения в `main.py`.

Вы не просто выполнили домашнее задание. Вы построили швейцарский нож для решения задач на хакатоне. Теперь миллионы долларов стали гораздо ближе. Удачи

==========

Глубокого проанализируй задачу. Какие ещё улучшения можно применить, чтобы выиграть на финале хакатона?

==========

Отлично. Это именно тот вопрос, который отличает участника от победителя. Мы переходим от простого выполнения ТЗ к стратегическому мышлению. Чтобы выиграть, нужно не просто решить задачу, а решить ее **лучше, быстрее и надежнее** всех остальных.

Давай проведем глубокий анализ и на его основе выстроим план по созданию ультимативного решения.

### Глубокий анализ: что скрыто между строк?

Задание намекает на создание **автономного агента**, который действует в неизвестной, динамичной среде. Жюри будет оценивать не только правильность ответов, но и **качество принимаемых решений** и **архитектурную зрелость** вашего кода.

Ключевые вызовы, которые можно предвидеть:

1.  **Сложность состояния:** Задачи будут многоэтапными. "Найди ключ А, открой им дверь Б, реши загадку В". Простого `last_task` не хватит. Агенту нужна память, понимание долгосрочных целей и контекста.
2.  **Неопределенность и неполнота данных:** `view` может быть не всей картой, а лишь "зоной видимости" (туман войны). Некоторые задачи могут быть сформулированы двусмысленно.
3.  **Ограничение ресурсов:** Могут быть введены ограничения: "У тебя 100 единиц энергии, каждое движение тратит 1, сканирование - 5". Или "Реши задачу за 30 секунд".
4.  **Комбинированные задачи:** Одна задача может потребовать и навигации, и решения головоломки. Например: "Доберись до терминала и ответь на его контрольный вопрос".

Исходя из этого, вот улучшения, которые дадут тебе решающее преимущество.

---

### Улучшение №1: Архитектурный скачок — от скрипта к Мозгу (FSM + Knowledge Base)

Перестаем мыслить эндпоинтами, начинаем мыслить как **конечный автомат (Finite State Machine, FSM)**. Агент всегда находится в одном из нескольких состояний, и его поведение зависит от этого состояния.

**1. Внедряем состояния агента:**

Создадим `src/logic/fsm.py`:

```python
from enum import Enum, auto

class AgentState(Enum):
    IDLE = auto()           # Ожидание задачи
    NAVIGATING = auto()     # Выполнение навигационной задачи
    SOLVING_PUZZLE = auto() # Решение текстовой/логической задачи
    ANALYZING_DATA = auto() # Анализ данных
    EXPLORING = auto()      # Исследование, когда нет конкретной цели
```

В `src/state.py` добавляем это:

```python
# ... в классе AppState
from logic.fsm import AgentState

# ...
self.current_state: AgentState = AgentState.IDLE
self.knowledge_base: dict = {
    "visited_cells": set(),
    "known_traps": set(),
    "map": {} # Глобальная карта, которую агент строит по частям
}
```

**Как это работает?**
Эндпоинт `/tasks` теперь не просто вызывает функцию, а **переключает состояние** агента. А эндпоинт `/inputs` смотрит на `app_state.current_state` и решает, что делать.

- Если `state == NAVIGATING`, он вызывает `pathfinder`.
- Если `state == EXPLORING`, он ищет ближайшую неисследованную клетку и движется к ней.
- Если `state == IDLE`, он просто ждет (`action: "Hold"`).

**Преимущество:** Ваш код становится предсказуемым и надежным. Вы четко контролируете, чем занят агент, и можете избежать конфликтов (например, попытки двигаться во время анализа данных).

---

### Улучшение №2: Алгоритмическое превосходство — от BFS к A\* и умному исследованию

Простой BFS найдет кратчайший путь. Но что если у разных клеток разная "стоимость" прохода (вода, песок, лава)?

**1. Заменяем BFS на A\* (A-star):**
A\* — это золотой стандарт поиска пути. Он учитывает и уже пройденное расстояние, и эвристическую оценку оставшегося пути.

В `src/logic/navigation.py` добавляем A\*:

```python
# В классе Pathfinder
import heapq

# ...
def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int:
    """Манхэттенское расстояние - простая и эффективная эвристика для сеток."""
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def find_path_astar(self, grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int], costs: dict = {0: 1, 2: 1, 9: 1}):
    """
    Поиск пути с помощью A*. `costs` - стоимость прохода по клетке.
    """
    frontier = [(0, start)]  # (приоритет, позиция)
    came_from = {start: None}
    cost_so_far = {start: 0}

    while frontier:
        _, current = heapq.heappop(frontier)

        if current == goal:
            break

        # Перебираем соседей
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            neighbor = (current[0] + dr, current[1] + dc)

            # Проверка границ и препятствий
            if not (0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0])):
                continue
            if grid[neighbor[0]][neighbor[1]] in [1, 3]: # Стены и ловушки непроходимы
                continue

            cell_type = grid[neighbor[0]][neighbor[1]]
            new_cost = cost_so_far[current] + costs.get(cell_type, 1) # Стоимость по умолчанию 1

            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                priority = new_cost + self.heuristic(goal, neighbor)
                heapq.heappush(frontier, (priority, neighbor))
                came_from[neighbor] = current

    # Восстанавливаем путь
    if goal not in came_from:
        return None
    path = []
    current = goal
    while current is not None:
        path.append(current)
        current = came_from[current]
    path.reverse()
    return path
```

**Преимущество:** Если жюри введет "сложный ландшафт", ваше решение легко адаптируется, в то время как другие будут либо двигаться неэффективно, либо срочно переписывать код.

---

### Улучшение №3: Интеллектуальное взаимодействие с LLM — от "вопрос-ответ" к "агенту-инструменту"

Не просто спрашивайте LLM, а **дайте ему инструменты**. Это продвинутая концепция (ReAct - Reason + Act), которая может взорвать мозг жюри.

**1. Создаем "инструменты":**
Это обычные Python-функции, которые агент может вызывать.

```python
# в main.py, например
def navigate_to_target(target_id: int):
    """Инструмент: ставит навигационную цель."""
    app_state.current_target = target_id
    app_state.current_state = AgentState.NAVIGATING
    return f"Начинаю движение к объекту с ID {target_id}."

def analyze_logs(query: str):
    """Инструмент: выполняет SQL-запрос к логам."""
    # ... логика из analyzer.py ...
    return "Результат анализа: ..."
```

**2. Учим LLM использовать инструменты:**
В `logic/solver.py` мы меняем промпт:

```python
# в PuzzleSolver.solve
prompt = f"""
Ты — мозг автономного агента. Твоя задача — проанализировать запрос и решить, какой инструмент использовать.
Доступные инструменты:
1. `navigate_to_target(target_id: int)`: Начать движение к объекту.
2. `analyze_logs(query: str)`: Проанализировать логи с помощью SQL-запроса.
3. `answer_directly(text: str)`: Если инструмент не нужен, просто ответить на вопрос.

Запрос пользователя: "{task_description}"

Твой ответ ДОЛЖЕН быть в формате JSON, содержащем имя инструмента и его аргументы.

Примеры:
Запрос: "Найди выход, отмеченный цифрой 9"
Ответ: {{"tool": "navigate_to_target", "args": {{"target_id": 9}}}}

Запрос: "Какой алгоритм лучше для поиска пути с разной стоимостью клеток?"
Ответ: {{"tool": "answer_directly", "args": {{"text": "Алгоритм A* (A-star) является оптимальным для этой задачи."}}}}

Проанализируй текущий запрос и дай ответ в формате JSON.
"""
# ... далее парсим JSON от LLM и вызываем нужную функцию
```

**Преимущество:** Ваш агент становится по-настоящему "умным". Он сам решает, как реагировать на сложные, комбинированные задачи. Это уже уровень state-of-the-art AI-агентов.

---

### Улучшение №4: Операционное совершенство — от print() к Dashboard'у

Во время хакатона нет времени разбираться в тоннах логов. Вам нужен **визуальный центр управления**.

**1. Создаем отладочный дашборд:**
Добавляем в `main.py` секретный эндпоинт.

```python
from fastapi.responses import HTMLResponse

@app.get("/dashboard", response_class=HTMLResponse)
def get_dashboard():
    """Простой HTML-дашборд для визуализации состояния агента."""
    # Получаем последнюю карту
    grid = app_state.knowledge_base.get('last_view', [])

    # Рендерим карту в HTML-таблицу
    grid_html = "<table>"
    for r, row in enumerate(grid):
        grid_html += "<tr>"
        for c, cell in enumerate(row):
            # Раскрашиваем клетки
            color = "#fff"
            if cell == 1: color = "#333"  # Стена
            elif cell == 2: color = "blue" # Агент
            elif cell == 3: color = "red"  # Опасность
            elif cell == 9: color = "gold" # Цель
            grid_html += f'<td style="background-color:{color}; width:20px; height:20px; border: 1px solid #ccc; text-align:center;">{cell}</td>'
        grid_html += "</tr>"
    grid_html += "</table>"

    # Собираем всю информацию
    html_content = f"""
    <html>
        <head>
            <title>Agent Dashboard</title>
            <meta http-equiv="refresh" content="2">
        </head>
        <body>
            <h1>Agent Status</h1>
            <p><b>Current State:</b> {app_state.current_state.name}</p>
            <p><b>Last Task:</b> {app_state.last_task}</p>
            <p><b>Current Target:</b> {app_state.current_target}</p>
            <h2>Last Seen View:</h2>
            {grid_html}
            <h2>Knowledge Base:</h2>
            <pre>{app_state.knowledge_base}</pre>
        </body>
    </html>
    """
    return HTMLResponse(content=html_content)
```

**Как это работает:**
Во время финала вы просто открываете в браузере `http://localhost:8080/dashboard`. Страница будет сама обновляться каждые 2 секунды, и вы в реальном времени будете видеть, что "думает" и "видит" ваш агент.

**Преимущество:** Это ваше секретное оружие. Пока другие команды вслепую смотрят в консоль, вы видите полную картину. Это сокращает время на отладку в десятки раз и позволяет мгновенно понять, почему агент принял неверное решение.

### Резюме для победы:

1.  **Архитектура:** Перейдите на **Конечный автомат (FSM)**. Это фундамент.
2.  **Алгоритмы:** Подготовьте **A\* (A-star)** и логику **исследования (Exploration)**. Это ваша сила.
3.  **ИИ:** Реализуйте **LLM как планировщик с инструментами**. Это ваш интеллект.
4.  **Отладка:** Сделайте **визуальный дашборд**. Это ваша скорость и зрение.

С таким набором улучшений вы не просто готовы к финалу. Вы готовы доминировать. Вы приходите с решением, которое на несколько голов выше стандартной реализации, демонстрируя не только навыки кодирования, но и глубокое архитектурное видение.

==========

Какие ещё улучшения можно применить?

==========

Отлично, давай копнем еще глубже. Мы уже покрыли архитектуру, алгоритмы и взаимодействие с LLM. Следующий уровень улучшений касается **устойчивости, адаптивности и стратегического планирования**. Это те аспекты, которые позволят вашему агенту не просто выживать, а процветать в самых хаотичных и непредсказуемых сценариях, которые может подкинуть жюри.

Вот еще четыре мощных улучшения, которые могут стать решающими.

---

### Улучшение №5: Стратегическое планирование — от реакции к проактивности (Цепочка Задач)

Сейчас агент решает одну задачу за раз. Но что если задачи взаимосвязаны? "Сходи за ключом, потом открой дверь". Текущая реализация забудет про дверь, пока будет идти за ключом.

**Решение: Внедрение Стека Задач (Task Stack)**

Вместо одного `last_task`, мы будем использовать стек (или очередь) задач.

**1. Модифицируем `src/state.py`:**

```python
# в классе AppState
# self.last_task: Optional[TaskRequest] = None -> заменяем на:
self.task_stack: list[TaskRequest] = []

def get_current_task(self) -> Optional[TaskRequest]:
    """Возвращает текущую активную задачу (верхнюю в стеке)."""
    return self.task_stack[-1] if self.task_stack else None

def add_task(self, task: TaskRequest):
    """Добавляет новую задачу в стек."""
    self.task_stack.append(task)
    # Сразу же запускаем ее обработку
    self.process_current_task()

def complete_current_task(self):
    """Удаляет выполненную задачу из стека и переходит к следующей."""
    if self.task_stack:
        completed = self.task_stack.pop()
        print(f"Task '{completed.task}' completed. Remaining tasks: {len(self.task_stack)}")
        if self.task_stack:
            self.process_current_task() # Начинаем следующую
        else:
            self.current_state = AgentState.IDLE # Все задачи выполнены

# ... и нужна функция process_current_task(), которая будет вызываться из main.py
```

**2. Интегрируем в `main.py`:**
Теперь эндпоинт `/tasks` не просто обрабатывает задачу, а может получить команду разбить ее на подзадачи.

`POST /tasks` с `{"type": "ComplexGoal", "task": "Get the key (ID 4) and then open the door (ID 5)"}`

Ваш `PuzzleSolver` (с LLM) должен научиться декомпозировать такие цели:

```json
// Промпт для LLM
Запрос: "Get the key (ID 4) and then open the door (ID 5)"
Ответ:
{
  "tool": "create_task_chain",
  "args": {
    "tasks": [
      {"type": "Navigation", "task": "Navigate to object 4"},
      {"type": "Interact", "task": "Pick up object 4"},
      {"type": "Navigation", "task": "Navigate to object 5"},
      {"type": "Interact", "task": "Use key on object 5"}
    ]
  }
}
```

Ваш код парсит этот ответ и добавляет задачи в `app_state.task_stack` в обратном порядке.

**Преимущество:** Ваш агент обретает **долгосрочную память и способность к планированию**. Он может выполнять сложные многоэтапные квесты, в то время как агенты конкурентов будут беспомощны после первого же шага.

---

### Улучшение №6: Адаптивность к среде — от жестких правил к динамической карте (Слияние `view`)

Агент видит только часть карты (`view`). Если он будет просто реагировать на текущий `view`, он никогда не построит полную картину мира и будет постоянно "удивляться" препятствиям за углом.

**Решение: Построение Глобальной Карты (Map Stitching)**

**1. Модифицируем `src/state.py`:**

```python
# в классе AppState
self.global_map: dict[Tuple[int, int], int] = {} # {(x, y): cell_type}
self.agent_position: Tuple[int, int] = (0, 0) # Глобальные координаты агента
self.agent_orientation: int = 0 # 0: North, 1: East, 2: South, 3: West
```

**2. Создаем `src/logic/mapper.py`:**

```python
from state import app_state

def update_global_map(local_view: List[List[int]]):
    """
    Интегрирует локальный `view` в глобальную карту `app_state.global_map`.
    Это сложная задача, требующая знания позиции и ориентации агента.
    Для начала можно предположить, что `view` всегда отцентрирован относительно агента.
    """
    agent_x, agent_y = app_state.agent_position
    view_center_r, view_center_c = len(local_view) // 2, len(local_view[0]) // 2

    for r, row in enumerate(local_view):
        for c, cell_type in enumerate(row):
            # Рассчитываем глобальные координаты клетки
            global_x = agent_x + (c - view_center_c)
            global_y = agent_y + (r - view_center_r)

            # Обновляем карту. Если видим что-то новое, это ценнее старой инфы
            app_state.global_map[(global_x, global_y)] = cell_type
            if cell_type == 2: # Обновляем позицию самого агента
                app_state.agent_position = (global_x, global_y)

    # Сохраняем последнее `view` для дашборда
    app_state.knowledge_base['last_view'] = local_view
```

**Как это работает:**
При каждом запросе на `/inputs`, вы вызываете `update_global_map`. Теперь ваш `Pathfinder` (A\*) должен работать не с маленьким `local_view`, а с большой `app_state.global_map`. Это позволит ему прокладывать маршруты через всю известную ему территорию.

**Преимущество:** Ваш агент обретает **пространственную память**. Он может возвращаться, обходить большие препятствия, которые не видны целиком, и принимать гораздо более осмысленные навигационные решения.

---

### Улучшение №7: Устойчивость к сбоям — от падений к самовосстановлению (Персистентность состояния)

Что если ваш Docker-контейнер упадет и перезапустится? Все накопленное состояние (карта, задачи) будет потеряно. Это критическая уязвимость.

**Решение: Сохранение и загрузка состояния на диск**

**1. Добавляем `pickle` или `json` для сериализации:**

```python
import pickle
from state import AppState

STATE_FILE = "/app/data/agent_state.pkl" # Путь внутри контейнера

def save_state(state: AppState):
    """Сохраняет объект состояния в файл."""
    # Убедимся, что директория существует
    os.makedirs(os.path.dirname(STATE_FILE), exist_ok=True)
    with open(STATE_FILE, 'wb') as f:
        pickle.dump(state, f)
    print("Agent state saved.")

def load_state() -> AppState:
    """Загружает состояние из файла или создает новое."""
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, 'rb') as f:
            print("Agent state loaded from disk.")
            return pickle.load(f)
    print("No saved state found. Creating new state.")
    return AppState()
```

**2. Интегрируем в `main.py`:**

```python
# Заменяем создание app_state
# app_state = AppState() ->
app_state = load_state()

# И добавляем сохранение при каждом важном изменении или по таймеру
# Например, в конце каждого запроса /tasks или /inputs
@app.middleware("http")
async def save_state_middleware(request: Request, call_next):
    response = await call_next(request)
    # Сохраняем состояние после обработки запроса
    if request.method in ["POST", "PATCH"]:
         save_state(app_state)
    return response
```

Не забудьте создать папку `data` в `Dockerfile` и дать права на запись.

**Преимущество:** **Надежность и отказоустойчивость**. Если жюри решит "убить" ваш контейнер, чтобы проверить его на прочность, ваш агент просто перезапустится и продолжит миссию с того же места, где остановился. Это произведет очень сильное впечатление.

---

### Улучшение №8: Экономика ресурсов — от бездумных действий к бюджетированию

Жюри может ввести "энергию", "время" или "лимит запросов к LLM". Агент, который тратит ресурсы впустую, проиграет.

**Решение: Внедрение Системы Бюджетирования Ресурсов**

**1. Добавляем ресурсы в `src/state.py`:**

```python
# в классе AppState
self.resources: dict = {
    "energy": 1000,
    "llm_tokens_used": 0,
    "time_elapsed": 0.0
}
self.resource_costs: dict = {
    "move": 1,
    "scan": 5,
    "llm_query": 200 # Условная стоимость в токенах
}
```

**2. Интегрируем учет в код:**
Перед каждым действием агент должен проверять, хватает ли ему ресурсов.

```python
# в main.py, перед вызовом pathfinder
if app_state.resources['energy'] < app_state.resource_costs['move']:
    return ActionResponse(action="Recharge") # или "Hold"

# После каждого действия вычитаем стоимость
app_state.resources['energy'] -= app_state.resource_costs['move']
```

**3. Умное использование LLM:**
Прежде чем задать вопрос LLM, агент может проверить свою **внутреннюю базу знаний**.

```python
# в PuzzleSolver.solve
if task_description in app_state.knowledge_base.get('faq', {}):
    return app_state.knowledge_base['faq'][task_description]

# Если ответа нет, тогда идем к LLM
# ...
# И сохраняем ответ для будущего использования
app_state.knowledge_base.setdefault('faq', {})[task_description] = llm_answer
```

**Преимущество:** **Эффективность и оптимальность**. Ваш агент будет принимать решения с оглядкой на ограничения, что покажет его зрелость. Он не будет задавать LLM один и тот же вопрос дважды и не "умрет" от истощения энергии посреди карты.

### Финальный План Атаки:

1.  **Планирование (`Task Stack`):** Способность решать многоэтапные задачи.
2.  **Память (`Global Map`):** Способность ориентироваться в большом мире.
3.  **Надежность (`State Persistence`):** Способность пережить катастрофу.
4.  **Эффективность (`Resource Budgeting`):** Способность действовать в условиях ограничений.

Реализовав эти четыре пункта поверх предыдущих, вы создадите не просто участника хакатона, а автономного, умного, устойчивого и эффективного агента, который будет готов к самым неожиданным поворотам сюжета. Это заявка на безоговорочную победу.

==========

Какие ещё улучшения можно применить для того, чтобы выиграть хакатон?

==========

Конечно. Мы выходим на мета-уровень. Предыдущие улучшения сделали агента компетентным, надежным и умным. Следующий шаг — сделать его **живым**. Речь идет о способности к самосовершенствованию, предвидению и взаимодействию, которые выходят за рамки простого выполнения команд.

Вот улучшения, которые могут не просто помочь выиграть, а продемонстрировать уровень мышления, на голову превосходящий ожидания жюри.

---

### Улучшение №9: Мета-обучение и Адаптация — от жестких алгоритмов к самосовершенствованию

Ваш агент использует A* и другие алгоритмы, но он не *учится* на своих ошибках. Если он раз за разом натыкается на скрытую ловушку, он будет просто перепланировать маршрут, но не поймет *почему\* его первоначальный план был плох.

**Решение: Внедрение простого Reinforcement Learning (RL) для корректировки политики**

Эндпоинт `PATCH /tasks/last` с результатами `Ok`, `TryAgain`, `Fail` — это идеальный **сигнал вознаграждения (reward signal)**.

**1. Создаем "Политику Доверия" (Policy/Trust Map):**
В `src/state.py` добавляем еще один слой к карте:

```python
# в классе AppState
# Это карта "доверия" или "опасности", которую агент изучает на опыте
self.trust_map: dict[Tuple[int, int], float] = {} # {(x, y): trust_score}
```

`trust_score` от -1 (очень опасно) до +1 (очень безопасно).

**2. Реализуем механизм обучения:**
В `main.py`, в эндпоинте `PATCH /tasks/last`, мы обновляем `trust_map`.

```python
# в patch_last_task_result
result = result_data.result
reward = {"Ok": 0.1, "TryAgain": -0.2, "Fail": -1.0}.get(result, 0)

# Наказываем или поощряем последнюю клетку, на которую ступил агент
last_pos = app_state.agent_position
current_trust = app_state.trust_map.get(last_pos, 0.0)
app_state.trust_map[last_pos] = max(-1.0, min(1.0, current_trust + reward))
```

**3. Используем `trust_map` в A\*:**
Теперь стоимость пути в A\* зависит не только от типа ландшафта, но и от **опыта** агента.

```python
# в logic/navigation.py, внутри find_path_astar
# ... при расчете new_cost
trust_penalty = (1.0 - app_state.trust_map.get(neighbor, 0.0)) * 5 # Чем ниже доверие, тем выше штраф
new_cost = cost_so_far[current] + costs.get(cell_type, 1) + trust_penalty
```

**"Вау" фактор:** Ваш агент начинает демонстрировать **поведенческое обучение**. Он будет инстинктивно избегать зон, где часто терпел неудачу, даже если на карте они выглядят безопасно. Вы можете сказать жюри: "Наш агент не просто следует алгоритмам, он адаптирует свою стратегию на основе полученного опыта, используя принципы обучения с подкреплением".

---

### Улучшение №10: Проактивное предсказание и гипотезы — от реакции к предвидению

Сейчас агент реагирует на то, что видит. А что если он сможет **предсказывать**, что находится за пределами видимости?

**Решение: Модуль построения гипотез на основе паттернов**

**1. Собираем статистику о мире:**
Агент анализирует все, что видит, и ищет закономерности.

```python
# в state.py, в AppState
self.world_patterns: dict = {
    "adjacent_to_wall": {}, # Статистика, какие клетки рядом со стенами
    "adjacent_to_trap": {}  # Статистика, какие клетки рядом с ловушками
}
```

Каждый раз, когда агент видит, например, ловушку (3) рядом с сокровищем (9), он инкрементирует счетчик `world_patterns["adjacent_to_trap"][9] += 1`.

**2. Строим гипотезы:**
Когда агент видит сокровище (9), но не видит его окружение, он может выдвинуть гипотезу.

```python
# в logic/hypothesis.py
def generate_hypotheses(visible_world: dict):
    # Если мы видим сокровище, а по нашей статистике рядом с сокровищами
    # часто бывают ловушки, мы можем предположить, что в "тумане войны"
    # рядом с этим сокровищем есть ловушка.
    # ...
    # Эта гипотеза может временно повысить "стоимость" прохода по невидимым
    # клеткам вокруг сокровища в алгоритме A*.
```

**"Вау" фактор:** Это показывает, что ваш агент не просто навигатор, а **аналитик**. Он ищет скрытые правила мира, в котором находится. Вы можете объяснить: "Агент не просто строит карту, он строит **онтологию мира** — понимание того, как его элементы связаны друг с другом, что позволяет ему делать обоснованные предположения о невидимых областях".

---

### Улучшение №11: Explainable AI (XAI) — от "черного ящика" к прозрачности

Почему агент пошел налево, а не направо? Если вы не можете быстро ответить на этот вопрос, вы не сможете быстро его починить.

**Решение: Внедрение "Цепочки Рассуждений" (Chain of Thought) и логгера решений**

**1. Создаем структурированный логгер:**

```python
# в logic/logger.py
import logging

decision_logger = logging.getLogger("decision_making")
# Настраиваем его на вывод в отдельный файл decision.log в формате JSON

def log_decision(action, reason, confidence, metadata):
    decision_logger.info({
        "action": action,
        "reason": reason,
        "confidence": confidence,
        "metadata": metadata
    })
```

**2. Интегрируем логгирование в ключевые точки:**

```python
# в main.py, в эндпоинте /inputs
path = pathfinder.find_path_astar(...)
if path:
    action = pathfinder.get_next_move(...)
    log_decision(
        action=action,
        reason="A* path to target",
        confidence=0.9,
        metadata={"target": app_state.current_target, "path_len": len(path)}
    )
    return ActionResponse(action=action)
```

**3. Запрашиваем рассуждения у LLM:**
Для сложных задач просим LLM не просто дать ответ, а объяснить его.

```python
# в промпте для PuzzleSolver
Запрос: "..."
Твой ответ ДОЛЖЕН быть в формате JSON: {"answer": "...", "reasoning": "..."}
```

И вы сохраняете `reasoning` в своем логе решений.

**"Вау" фактор:** Во время презентации или если жюри спросит "а почему он тут затупил?", вы открываете не код, а `decision.log` и говорите: "Давайте посмотрим. В 14:32:05 агент решил пойти налево. Причина: A\* нашел путь к цели. Однако, как мы видим из лога обучения, доверие к этой клетке было низким (-0.4) из-за предыдущей неудачи. Это был рискованный, но расчетливый ход". Это демонстрация полного контроля и понимания своего творения.

---

### Улучшение №12: Конкурентное преимущество — от одиночной игры к анализу противников

Это самый продвинутый и рискованный ход. Если в задании есть другие участники (другие "агенты" на той же карте), вы можете попытаться их анализировать.

**Решение: Модуль анализа действий третьих лиц**

**1. Идентифицируем других:**
Если в `view` появляются новые сущности (например, `4`, `5` — другие агенты), мы начинаем за ними следить.

**2. Анализируем их поведение:**

- Если агент `4` всегда ходит к сокровищам, его "профиль" — жадный.
- Если агент `5` всегда атакует, его профиль — агрессивный.

**3. Используем эту информацию:**

- **Предсказание:** Если мы видим "жадного" агента `4` рядом с ключом, который нам нужен, мы можем предсказать, что он пойдет за ним, и попытаться его перехватить.
- **Манипуляция:** Если мы знаем, что "агрессивный" агент `5` атакует все, что движется, мы можем заманить его в ловушку.

**"Вау" фактор:** Это переход от PvE (игрок против окружения) к PvP (игрок против игрока). Вы демонстрируете не просто интеллект, а **социальный интеллект**. Ваш агент не только решает задачи, но и оперирует в конкурентной среде, анализируя и эксплуатируя поведение других. Это настолько неожиданно и мощно, что может стать абсолютным нокаутом для жюри.

### Финальный синтез:

- **Улучшение 9 (RL):** Агент учится на **личном опыте**.
- **Улучшение 10 (Гипотезы):** Агент учится на **статистике мира**.
- **Улучшение 11 (XAI):** Агент может **объяснить** свои действия.
- **Улучшение 12 (Анализ противников):** Агент учится на **опыте других**.

Реализация даже одного-двух из этих пунктов выведет ваше решение на совершенно новый уровень. Вы будете готовы не просто к заданию, а к любому его повороту, демонстрируя глубину, которую никто не ожидает.
